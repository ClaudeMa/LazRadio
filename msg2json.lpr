program msg2json;

uses
  SysUtils, Classes, superobject, RegExpr;

type

  TLineProc = procedure(S: string);

var
  FI, FO: TextFile;
  State: TLineProc;
  S: string;
  LastIndent: Integer;
  FHIndent: Integer;
  FHI: Integer;
  FLIndent: Integer;
  FLI: Integer;
  Comments: TStringList;
  Msg: ISuperObject;
  ReIdV: TRegExpr;
  ReComment: TRegExpr;
  ErrCnt: Integer = 0;

procedure Emit(const S: string);
begin
  Write(FO, S);
end;

procedure EmitLn(const S: string);
begin
  Writeln(FO, S);
end;

procedure Error(const S: string);
begin
  Writeln(S);
  Inc(ErrCnt);
end;

procedure WaitConst(S: string); forward;

function ReadV(const S: string; out Identifier: string; out V: Integer; out Comment: string): Boolean;
begin
  Result := ReIdV.Exec(S);
  if not Result then Exit;
  Identifier := ReIdV.Match[1];
  V := StrToInt(ReIdV.Match[2]);
  Comment := '';
  if ReComment.Exec(S) then
    Comment := ReComment.Match[1];
end;

function RemoveIndent(var S: string): Integer;
begin
  Result := 0;
  while (Result < Length(S)) and (S[Result + 1] = ' ') do Inc(Result);
  Delete(S, 1, Result);
end;

procedure TryWrite;
begin
  if Msg.AsObject.count > 0 then
  begin
    Emit(Msg.AsJSon(True));
    EmitLn(',');
    Msg := SO('{}');
  end;
end;

procedure NewMsg(S: string);
var
  Indent: Integer;
  Identifier: string;
  Comment: string;
  Code: Integer;
  Path: string;
begin
  Indent := RemoveIndent(S);
  if Pos('type', S) = 1 then
  begin
    State := @WaitConst;
    Exit;
  end;
  if Length(S) = 0 then
  begin
    TryWrite;
    Comments.Clear;
    Exit;
  end;

  if Pos('//', S) = 1 then
  begin
    Delete(S, 1, 2);
    Comments.Add(Trim(S));
    Exit;
  end;

  if not ReadV(S, Identifier, Code, Comment) then
      Exit;
  Comments.Add(Comment);

  if Indent = 2 then
  begin
    FHIndent := 0;
    FLIndent := 0;

    TryWrite;
    Msg.S['name'] := Identifier;
    Msg.I['id'] := Code;
    Msg.S['doc'] := Comments.DelimitedText;
    Msg.O['paramh'] := SO('{type: "any"}');
    Comments.Clear;
  end
  else if Indent > 2 then
  begin
    if FHIndent = 0 then
    begin
      Msg.S['paramh.type'] := 'enum';
      Msg.O['paramh.vals'] := TSuperObject.Create(stArray);
      FHI := -1;
      FHIndent := Indent;
    end;
    if Indent = FHIndent then
    begin
      Inc(FHI);
      Path := Format('paramh.vals[%d]', [FHI]);
      Msg.O[Path] := SO('{}');
      Msg.S[Path + '.name'] := Identifier;
      Msg.I[Path + '.id'] := Code;
      Msg.S[Path + '.doc'] := Comments.DelimitedText;
      Msg.O[Path + '.paraml'] := SO('{type: "any"}');
      Comments.Clear;
      FLIndent := 0;
    end
    else if Indent > FHIndent then
    begin
      if FLIndent = 0 then
      begin
        Path := Format('paramh.vals[%d]', [FHI]);
        Msg.S[Path + '.paraml.type'] := 'enum';
        Msg.O[Path + '.paraml.vals'] := TSuperObject.Create(stArray);
        FLI := 0;
        FLIndent := Indent;
      end;

      if Indent = FLIndent then
      begin
        Path := Format('paramh.vals[%d].paraml.vals[%d]', [FHI, FLI]);
        Msg.O[Path] := SO('{}');
        Msg.S[Path + '.name'] := Identifier;
        Msg.I[Path + '.id'] := Code;
        Msg.S[Path + '.doc'] := Comments.DelimitedText;
        Comments.Clear;
        Inc(FLI);
      end
      else
         Error(Format('indent Error 2: HIndent = %d, LIndent = %d, Indent = %d, S = %s', [FHIndent, FLIndent, Indent, S]));
    end
    else begin
      // error
      Error(Format('indent Error 1: HIndent = %d, Indent = %d, S = %s', [FHIndent, Indent, S]));
    end;
  end;
end;

procedure WaitConst(S: string);
begin
  if Pos('const', S) = 1 then
  begin
    LastIndent := -1;
    State := @NewMsg;
  end;
end;

begin
  State := @WaitConst;
  Comments := TStringList.Create;
  Comments.Delimiter := #10;
  Comments.StrictDelimiter := True;
  ReIdV := TRegExpr.Create;
  ReIdV.Expression := '^([A-Z_][A-Z_0-9]+)\s*=\s*([0-9]+)\s*;.*';     // RM_CONFIGURE       = 8;
  ReComment := TRegExpr.Create;
  ReComment.Expression := '//\s*(.+)';
  Msg := SO('{}');

  Assign(FI, 'radiomessage.pas');
  Reset(FI);

  Assign(FO, '.\res\messages.json');
  Rewrite(FO);

  Emitln('/* generated by msg2json. modification not recommended. */');
  Emitln('[');
  while not EOF(FI) do
  begin
    Readln(FI, S);
    State(S);
  end;
  CloseFile(FI);
  TryWrite;
  EmitLn(']');
  CloseFile(FO);

  if ErrCnt > 0 then
    Error('there are errors: ' + IntToStr(ErrCnt))
  else
    Error('succeeded.');

  Readln;
end.

